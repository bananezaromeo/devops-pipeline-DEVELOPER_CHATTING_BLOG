---
- name: Create application directory
  file:
    path: /opt/devops-app
    state: directory
    owner: "{{ ansible_user }}"
    group: docker
    mode: '0755'

- name: Debug Ansible variables
  debug:
    msg: "acr_name={{ acr_name }}, acr_login_server={{ acr_login_server }}"

- name: Login to Azure Container Registry
  shell: |
    az login --service-principal -u $AZURE_CLIENT_ID -p $AZURE_CLIENT_SECRET --tenant $AZURE_TENANT_ID
    az acr login --name "{{ acr_name }}"
  environment:
    AZURE_CLIENT_ID: "{{ lookup('env', 'ARM_CLIENT_ID') }}"
    AZURE_CLIENT_SECRET: "{{ lookup('env', 'ARM_CLIENT_SECRET') }}"
    AZURE_TENANT_ID: "{{ lookup('env', 'ARM_TENANT_ID') }}"

- name: Create docker-compose file
  template:
    src: docker-compose.yml.j2
    dest: /opt/devops-app/docker-compose.yml
    owner: "{{ ansible_user }}"
    mode: '0644'

- name: Create environment file
  template:
    src: .env.j2
    dest: /opt/devops-app/.env
    owner: "{{ ansible_user }}"
    mode: '0600'

- name: Show docker-compose file content
  shell: cat /opt/devops-app/docker-compose.yml
  register: compose_content

- name: Debug docker-compose
  debug:
    msg: "{{ compose_content.stdout }}"

- name: Pull latest images
  community.docker.docker_compose:
    project_src: /opt/devops-app
    pull: yes
  register: pull_result
  ignore_errors: yes

- name: Show pull errors
  debug:
    msg: "Pull result: {{ pull_result }}"

- name: Check Docker daemon status
  shell: docker ps
  register: docker_ps

- name: Show Docker status
  debug:
    msg: "Docker running containers: {{ docker_ps.stdout }}"

- name: Manual docker-compose up with verbose output
  shell: |
    cd /opt/devops-app
    docker-compose down --remove-orphans 2>&1 || true
    docker-compose up -d 2>&1
  register: compose_up
  ignore_errors: yes

- name: Show docker-compose up output
  debug:
    msg: "Docker compose output:\n{{ compose_up.stdout }}\n{{ compose_up.stderr }}"

- name: Check running containers
  shell: docker ps -a
  register: docker_containers

- name: Show all containers
  debug:
    msg: "All containers:\n{{ docker_containers.stdout }}"

- name: Check container logs
  shell: docker logs backend 2>&1 || true
  register: backend_logs

- name: Show backend logs
  debug:
    msg: "Backend logs:\n{{ backend_logs.stdout }}"

- name: Check if port 80 is listening
  shell: netstat -tuln | grep 80 || ss -tuln | grep 80 || echo "Port 80 status check completed"
  register: port_80_status
  ignore_errors: yes

- name: Show port 80 status
  debug:
    msg: "Port 80 status:\n{{ port_80_status.stdout }}"

- name: Check UFW status
  shell: ufw status | grep 80 || echo "UFW check completed"
  register: ufw_status
  ignore_errors: yes

- name: Show UFW status
  debug:
    msg: "UFW port 80 status:\n{{ ufw_status.stdout }}"

- name: Wait for application to be ready
  uri:
    url: "http://localhost:5000/health"
    status_code: 200
  register: result
  until: result.status == 200
  retries: 30
  delay: 2

- name: Check frontend container logs
  shell: docker logs frontend 2>&1 || true
  register: frontend_logs
  ignore_errors: yes

- name: Show frontend logs
  debug:
    msg: "Frontend logs:\n{{ frontend_logs.stdout }}"

- name: Check port 80 on host
  shell: netstat -tuln 2>/dev/null | grep ':80 ' || ss -tuln 2>/dev/null | grep ':80 ' || echo "Port 80 not found"
  register: host_port_80
  ignore_errors: yes

- name: Show host port 80
  debug:
    msg: "Host port 80:\n{{ host_port_80.stdout }}"

- name: Test frontend locally
  shell: curl -v http://localhost/ 2>&1 || true
  register: frontend_test
  ignore_errors: yes

- name: Show frontend test
  debug:
    msg: "Frontend local test:\n{{ frontend_test.stdout }}\n{{ frontend_test.stderr }}"

- name: Check Docker network
  shell: docker network inspect app-network 2>&1 || true
  register: docker_network
  ignore_errors: yes

- name: Show Docker network
  debug:
    msg: "Docker network:\n{{ docker_network.stdout }}"
